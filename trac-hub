#!/usr/bin/env ruby

require 'json'
require 'logger'
require 'rest-client'
require 'optparse'
require 'sequel'
require 'yaml'
require 'set'
require 'singleton'
require 'digest'
require 'gqli'
require 'git'

module LabelTypes
  TYPE = 'type'
  PRIORITY = 'priority'
  COMPONENT = 'component'
  PLATFORM = 'platform'
end

class GracefulQuit
  include Singleton

  attr_accessor :breaker

  def initialize
    self.breaker = false
  end

  def self.enable
    trap('INT') {
      yield if block_given?
      self.instance.breaker = true
    }
  end

  def self.check(message = "Quitting")
    if self.instance.breaker
      yield if block_given?
      puts message
      exit
    end
  end

end

class Migrator
  def initialize(trac, github, users, labels, revmap, attachurl, singlepost, safetychecks)
    @trac = trac
    @repo = github['repo']
    @token = github["token"]

    @users = Hash[users]
    @labels = Hash[labels.map { |cat, rx| [cat, Hash[rx]] }]
    @ticket_to_issue = {}
    @trac_mails_cache = Hash.new
    @gclient = GQLi::Client.new(
      "https://api.github.com/graphql",
      headers: { "Authorization" => "token #{@token}" },
      validate_query: false
    )

    # create milestones hash
    @milestones = Hash.new
    page = 1
    loop do
      ms = JSON.parse(RestClient.get(
        "https://api.github.com/repos/#{@repo}/milestones",
        { "Authorization" => "token #{@token}",
          params: {
            page: page,
            state: "all",
            per_page: "100"
          } }
      ))
      if ms.length == 0
        break
      end
      @milestones.merge!(ms.map {
        |x| [x["title"], x["html_url"]]
      }.to_h)
      page += 1
    end

    #findMapping

    #deleteDummyTickets
    comps = @repo.split("/")
    query = GQLi::DSL.query {
      repository(owner: comps[0], name: comps[1]) {
        issues(last: 1) {
          edges {
            node {
              number
            }
          }
        }
      }
    }
    result = @gclient.execute(query)
    @last_created_issue = 0
    edges = result.data.repository.issues.edges
    @last_created_issue = edges[0].node.number unless edges.empty?

    $logger.info("Last created issue on GitHub is '#{@last_created_issue}'")

    # $logger.debug("Get all labels")
    # page = 1
    # existingLabels = []
    # loop do
    #   rlabels = JSON.parse(RestClient.get(
    #     "https://api.github.com/repos/#{@repo}/labels",
    #     { "Authorization" => "token #{@token}",
    #       params: {
    #         page: page,
    #         per_page: "100"
    #       } }
    #   ))
    #   if rlabels.length() == 0
    #     break
    #   end
    #   rlabels.each do |label|
    #     existingLabels << label['name']
    #   end
    #   page += 1
    # end
    #
    # $logger.info("Create missing labels")
    # @labels.each do |cat|
    #   type = cat[0]
    #   $logger.info("Processing type #{type}")
    #   cat[1].values.each do |v|
    #     l = "#{type}:#{v}"
    #     unless existingLabels.include? l
    #       $logger.info("Creating label #{l}")
    #       JSON.parse(RestClient.post(
    #         "https://api.github.com/repos/#{@repo}/labels",
    #         { "name" => l }.to_json,
    #         { "Authorization" => "token #{@token}",
    #           "Content-Type" => "application/json",
    #           "Accept" => "application/vnd.github.v3+json" }))
    #     end
    #   end
    # end

    @revmap = revmap
    @attachurl = attachurl
    @singlepost = singlepost
    @safetychecks = safetychecks
  end

  def findMapping()
    $logger.info("Find mapping")

    Git.configure do |config|
      # If you want to use a custom git binary
      config.binary_path = '/usr/local/bin/git'
    end

    g = Git.open("/Users/yla/workspace/cyberduck", :log => Logger.new(STDOUT))
    gitlog = g.log(1000000)

    open('missing-mappings.out', 'a') do |f|
      revisions = File.readlines('missing.out', chomp: true).uniq
      revisions.each do |revision|
        found = false
        #$logger.info("Processing " + revision)
        data = @trac.revisions.select().filter(:rev => revision.rjust(10, '0')).first
        if data
          gitlog.each do |commit|
            if commit.date == Time.at(data[:time] / 1000000)
              f << "r#{revision} #{commit.sha}\n"
              found = true
              break
            end
          end
        else
          if !found
            $logger.info("Revision #{revision} not mapped")
          end
        end
      end
    end
    exit
  end

  def deleteDummyTickets()
    $logger.info("Delete dummy tickets")
    page = 1
    loop do
      issues = JSON.parse(RestClient.get(
        "https://api.github.com/repos/#{@repo}/issues",
        { "Authorization" => "token #{@token}",
          params: {
            filter: "all",
            state: "all",
            sort: "created",
            direction: "desc",
            page: page,
            per_page: 100
          } }
      ))
      if issues.length() == 0
        break
      end
      issues.each do |issue|
        if issue["title"].include? "dummy"
          $logger.info("Delete dummy ticket " + issue["number"].to_s)
          query = GQLi::DSL.mutation {
            deleteIssue(input: { issueId: "#{issue['node_id']}" }) {
              clientMutationId
            }
          }
          @gclient.execute(query)
        end
      end
      page += 1
    end
  end

  def migrateVersions

    # milestones lÃ¶schen
=begin
    n = 1
    while true
      RestClient.delete(
        "https://api.github.com/repos/#{@repo}/milestones/#{n}",
        { "Authorization" => "token #{@token}",
          "Content-Type" => "application/json",
          "Accept" => "application/vnd.github.v3+json" })
      n+=1
    end
=end

    n = 0

    @trac.milestones.all.each do |milestone|
      $logger.info("Processing milestone #{milestone[:name]}")

      description = ""
      description = "*Closed on #{Time.at(milestone[:completed] / 1000000).utc}*" if milestone[:completed] > 0
      description = description + "\n\n" + milestone[:description] unless milestone[:description].nil?

      request = {}
      request["title"] = milestone[:name]
      request["state"] = milestone[:completed] > 0 ? "closed" : "open"
      request["description"] = description unless description.empty?
      request["due_on"] = Time.at(milestone[:due] / 1000000).utc.iso8601 if milestone[:due] > 0

      response = JSON.parse(RestClient.post(
        "https://api.github.com/repos/#{@repo}/milestones",
        request.to_json,
        { "Authorization" => "token #{@token}",
          "Content-Type" => "application/json",
          "Accept" => "application/vnd.github.v3+json" }))
    end
  end

  def migrate(start_ticket = -1, filterout_closed = false)
    if start_ticket == -1
      start_ticket = @last_created_issue + 1
    end
    GracefulQuit.enable
    migrate_tickets(start_ticket, filterout_closed)
  end

  private

  # returns the author mail if found, otherwise author itself
  def trac_mail(author)
    return @trac_mails_cache[author] if @trac_mails_cache.has_key?(author)
    # tries to retrieve the email from trac db
    #data = @trac.sessions.select(:value).where('name = "email" AND sid = ?', author)
    data = @trac.sessions.select(:value).filter(:name => 'email').filter(:sid => author)

    $logger.info("trac_mail -> data found " + author)

    #exit
    return (@trac_mails_cache[author] = data.first[:value]) if data.count == 1
    return (@trac_mails_cache[author] = author) # not found
  end

  # returns the git commit hash for a specified revision (using revmap hash)
  def map_changeset(str)
    if @revmap and @revmap.has_key?(str)
      return "#{@revmap[str]}"
    else
      return str
    end
  end

  # returns the milestone URL (using a map)
  def map_milestone(label, milestone)
    if @milestones and @milestones.has_key?(milestone)
      if label
        return "[#{label}](#{@milestones[milestone]})"
      else
        return "[#{milestone}](#{@milestones[milestone]})"
      end
    else
      $logger.info("Milestone #{milestone} not found")
      return "[milestone:#{milestone} #{milestone}]"
    end
  end

  # Format time for github API
  def format_time(time)
    time = Time.at(time / 1e6, time % 1e6)
    return time.strftime("%FT%TZ")
  end

  # Creates github issues for trac tickets.
  def migrate_tickets(start_ticket, filterout_closed)
    $logger.info('migrating issues')
    # We match the issue title to determine whether an issue exists already.
    @trac.tickets.order(:id).where { id >= start_ticket }.all.each do |ticket|
      next if filterout_closed and ticket[:status] == "closed"
      GracefulQuit.check("quitting after processing ticket ##{@last_created_issue}")

      if @safetychecks;
        begin
          # issue exists already:
          issue = JSON.parse(RestClient.get(
            "https://api.github.com/repos/#{@repo}/issues/#{ticket[:id]}",
            { "Authorization" => "token #{@token}" }))
          $logger.info("found ticket #{ticket[:id]}")
          next
        rescue
        end
      end

      begin
        # check if there is gap in numbering in case of deleted trac tickets
        if @last_created_issue + 1 < ticket[:id]
          $logger.info("Next issue will be #{@last_created_issue + 1} but TRAC ticket number to migrate is #{ticket[:id]} - create dummy ticket(s)")
          dummy = {
            "issue" => { "title" => "dummy", "body" => "dummy", "closed" => true, "created_at" => "1900-01-01T00:00:00Z" },
            "comments" => []
          }
          (ticket[:id] - (@last_created_issue + 1)).times {
            $logger.info("Create dummy ticket")
            response = JSON.parse(RestClient.post(
              "https://api.github.com/repos/#{@repo}/import/issues",
              dummy.to_json,
              { "Authorization" => "token #{@token}",
                "Content-Type" => "application/json",
                "Accept" => "application/vnd.github.golden-comet-preview+json" }))
            while response["status"] == "pending"
              sleep 1.0
              $logger.info("Checking import status: #{response['id']}")
              response = JSON.parse(RestClient.get(response['url'], {
                "Authorization" => "token #{@token}",
                "Accept" => "application/vnd.github.golden-comet-preview+json" }))
            end
          }
        end

        $logger.info("creating issue #{ticket[:id]} (#{ticket[:reporter]})")
        # API details: https://gist.github.com/jonmagic/5282384165e0f86ef105
        request = compose_issue(ticket)
        response = JSON.parse(RestClient.post(
          "https://api.github.com/repos/#{@repo}/import/issues",
          request.to_json,
          { "Authorization" => "token #{@token}",
            "Content-Type" => "application/json",
            "Accept" => "application/vnd.github.golden-comet-preview+json" }))
      end

      if @safetychecks
        while response["status"] == "pending"
          sleep 1.0
          $logger.info("Checking import status: #{response['id']}")
          response = JSON.parse(RestClient.get(response['url'], {
            "Authorization" => "token #{@token}",
            "Accept" => "application/vnd.github.golden-comet-preview+json" }))
        end
        $logger.info("Status: #{response['status']}")
        issue_id = response["issue_url"].match(/\d+$/).to_s.to_i

        $logger.info("created issue ##{issue_id} for ticket #{ticket[:id]}")

        # assert correct issue number
        if issue_id != ticket[:id]
          $logger.info("mismatch issue ##{issue_id} for ticket #{ticket[:id]}")
          exit 1
        end
      else
        # to allow manual verification:
        $logger.info(response['url'])
      end

      # lock ticket if it's closed
      if ticket[:status] == "closed"
        RestClient.put(
          "https://api.github.com/repos/#{@repo}/issues/#{ticket[:id]}/lock",
          { "lock_reason" => "resolved" }.to_json,
          { "Authorization" => "token #{@token}",
            "Content-Type" => "application/json",
            "Accept" => "application/vnd.github.v3+json" })
      end

      @last_created_issue = ticket[:id]

      #exit
    end
  end

  def compose_issue(ticket)

    body = ""
    #body += "*Issue migrated from trac ticket # #{ticket[:id]}*\n\n"
    closed = nil

    # summary line:
    # body += [:component, :priority, :resolution, :keywords].map {
    #   |cat| ticket[cat] and not ticket[cat].lstrip.empty? and
    #     "**#{cat.to_s}:** #{ticket[cat]}"
    # }.select { |x| x }.join(" | ")

    # Initial report
    # TODO: respect ticket[:changetime]
    # body += "\n\n" if not @singlepost
    body += ticket_change(@singlepost, {
      ticket: ticket[:id],
      time: ticket[:time],
      author: ticket[:reporter],
      field: :initial,
      oldvalue: nil,
      newvalue: ticket[:description],
    })["body"]

    # Attachments
    #
    @trac.attachments.where(:type => 'ticket', :id => ticket[:id]).all.each_with_index do |attachment, i|
      body += "\n___\nAttachments\n" if i == 0
      name = attachment[:filename]
      size = attachment[:size]
      url = @attachurl + "/#{ticket[:id]}/" + CGI.escape(name).gsub("+", "%20")
      text = "\n* [`#{name}`](#{url})"
      text += " (#{(size / 1024.0).round(1)} KiB)"
      body += text
    end

    # combine the changes and attachment table results and sort them by date
    changes = @trac.changes.where(:ticket => ticket[:id]).collect.to_a
    changes += @trac.attachments.where(:type => 'ticket', :id => ticket[:id]).collect.to_a
    changes = changes.sort_by { |x| x[:time] }

    # replay all changes in chronological order:
    comments = changes.map { |x| ticket_change(@singlepost, x) }.select { |x| x }.to_a
    if @singlepost
      body += comments.map { |x| x["body"] }.join("\n")
      comments = []
    end

    labels = Set[]
    changes.each do |x|
      # del = @labels.fetch(x[:field], Hash[])[x[:oldvalue]]
      # add = @labels.fetch(x[:field], Hash[])[x[:newvalue]]
      # labels.delete(del) if del
      # labels.add(add) if add
      if x[:field] == "status" and x[:newvalue] == "closed"
        closed = x[:time]
      end
    end
    labels.add('component:' + @labels.fetch('component', Hash[])[ticket[:component]])
    labels.add('type:' + @labels.fetch('type', Hash[])[ticket[:type]])
    labels.add('resolution:' + @labels.fetch('resolution', Hash[])[ticket[:resolution]]) unless ticket[:resolution].nil? || ticket[:resolution].empty?
    labels.add('priority:' + @labels.fetch('priority', Hash[])[ticket[:priority]])
    # labels.add(@labels.fetch('severity', Hash[])[ticket[:severity]])
    labels.add('version:' + @labels.fetch('version', Hash[])[ticket[:version]]) unless ticket[:version].nil? || ticket[:version].empty?
    # If the field is not set, it will be nil and generate an unprocessable json
    labels.delete(nil)

    issue = {
      "title" => ticket[:summary],
      "body" => body,
      "labels" => labels.to_a,
      "closed" => ticket[:status] == "closed",
      "created_at" => format_time(ticket[:time]),
    }
    if @users.has_key?(ticket[:owner])
      owner = trac_mail(ticket[:owner])
      github_owner = @users[owner]
      $logger.debug("..owner in trac: #{owner}")
      $logger.debug("..assignee in GitHub: #{github_owner}")
      issue["assignee"] = github_owner
    end

    if ticket[:changetime]
      issue["updated_at"] = format_time(ticket[:changetime])
    end
    if issue["closed"] and closed
      issue["closed_at"] = format_time(closed)
    end

    return {
      "issue" => issue,
      "comments" => comments,
    }
  end

  def ticket_change(append, meta)

    # kind
    if meta[:ticket]
      kind = meta[:field]
    else
      kind = 'attachment'
    end
    kind = 'title' if kind == 'summary'

    # time
    time = meta[:time]
    time = Time.at(time / 1e6, time % 1e6)

    # author
    author = meta[:author]
    author = trac_mail(author)
    if @users.has_key?(author)
      author = "@" + @users[author]
    end

    pos = author.index("@")
    unless pos.nil? || pos == 0
      author = (Digest::SHA1.hexdigest author)[0..6]
    end

    text = ""
    text += "> **#{author}** "

    case kind
    when 'owner', 'status', 'title', 'resolution', 'priority', 'component', 'type', 'severity', 'platform'
      return nil
      old = meta[:oldvalue]
      new = meta[:newvalue]
      if old and new
        text += "changed #{kind} from *#{old}* to *#{new}*"
      elsif old
        text += "removed #{kind} (was *#{old}*)"
      elsif new
        text += "set #{kind} to *#{new}*"
      end

    when :initial
      body = meta[:newvalue]
      text += "created the issue\n\n"
      if body and not body.lstrip.empty?
        text += markdownify(body, meta[:ticket])
      end

    when 'milestone'
      return nil

    when 'comment'
      body = meta[:newvalue]
      text += "commented\n\n"
      text += markdownify(body, meta[:ticket]) if body
      return nil if body == nil or body.lstrip.empty?

    when 'attachment'
      return nil
      text += "uploaded file "
      name = meta[:filename]
      body = meta[:description]
      if @attachurl
        # uri = Addressable::URI.parse(@attachurl)
        # uri.query_values = {title: "My Blog & Your Blog"}
        # url = uri.normalize.to_s

        url = @attachurl + "/#{meta[:id]}/" + CGI.escape(name).gsub("+", "%20")
        text += "[`#{name}`](#{url})"
        if [".png", ".jpg", ".gif"].include? File.extname(name).downcase
          body += "\n![#{name}](#{url})"
        end
      else
        text += "`#{name}`"
      end
      text += " (#{(meta[:size] / 1024.0).round(1)} KiB)"
      text += "\n\n" + body

    when 'description'
      return nil
      # (ticket[:description] already contains the new value,
      # so there is no need to update)
      text += "edited the issue description"

    when 'keywords', 'cc', 'reporter', 'version'
      # don't care
      return nil

    else
      return nil
    end

    return {
      "body" => text,
      "created_at" => format_time(meta[:time]),
    }
  end

  def markdownify(str, ticketid)
    # Line endings
    str.gsub!("\r\n", "\n")
    # CommitTicketReference
    str.gsub!(/\{\{\{\n(#!CommitTicketReference .+?)\}\}\}/m, '\1')
    str.gsub!(/#!CommitTicketReference .+\n/, '')
    # Code
    str.gsub!(/\{\{\{([^\n]+?)\}\}\}/, '`\1`')
    str.gsub!(/\{\{\{(.+?)\}\}\}/m, '```\1```')
    str.gsub!(/(?<=```)#!/m, '')
    # Headings
    str.gsub!(/\=\=\=\=\s(.+?)\s\=\=\=\=/, '#### \1')
    str.gsub!(/\=\=\=\s(.+?)\s\=\=\=/, '### \1')
    str.gsub!(/\=\=\s(.+?)\s\=\=/, '## \1')
    str.gsub!(/\=\s(.+?)\s\=[\s\n]*/, '# \1')
    # Images
    str.gsub!(/\[\[Image\((http[^\s\[\]]+)\)\]\]/) { |m|
      "![external image](#{$1})"
    }
    str.gsub!(/\[\[Image\(([^:\[\]]+)\)\]\]/) { |m|
      filename = "#{$1}"
      url = @attachurl + "/#{ticketid}/" + CGI.escape(filename).gsub("+", "%20")
      "![#{filename}](#{url})"
    }
    # Line Breaks
    str.gsub!(/\[\[BR\]\]/, '<br />')
    # Links
    str.gsub!(/\[\[(http[^\s\[\]]+)\|([^\[\]]+)\]\]/, '[\2](\1)')
    str.gsub!(/\[(http[^\s\[\]]+)\s([^\[\]]+)\]/, '[\2](\1)')
    str.gsub!(/\[(http[^\s\[\]]+)\]/, '(\1)')
    str.gsub!(/\!(([A-Z][a-z0-9]+){2,})/, '\1')
    # Font styles
    str.gsub!(/'''(.+?)'''/, '**\1**')
    str.gsub!(/''(.+?)''/, '*\1*')
    str.gsub!(/[^:]\/\/(.+?[^:])\/\//, '_\1_')
    # Lists
    str.gsub!(/(^\s+)\*/, '\1-')
    str.gsub!(/(^\s+)(\d)\./, '\1\2.')
    # Changeset
    str.gsub!(/https?:\/\/svnweb.cern.ch\/trac\/madx\/changeset\/(\d+)\/?/, '[changeset:\1]')
    str.gsub!(/\[changeset:"r(\d+)".*\]/, '[changeset:\1]')
    str.gsub!(/\[changeset:r(\d+)\]/, '[changeset:\1]')
    str.gsub!(/\br(\d+)\b/) { map_changeset(Regexp.last_match[1]) }
    str.gsub!(/\[changeset:"(\d+)".*\]/) { map_changeset(Regexp.last_match[1]) }
    str.gsub!(/\[changeset:(\d+)\]/) { map_changeset(Regexp.last_match[1]) }
    str.gsub!(/\[milestone:([\d.]+)\s([^\]]+)\]/) { map_milestone(Regexp.last_match[2], Regexp.last_match[1]) }
    str.gsub!(/\[milestone:([\d.]+)\]/) { map_milestone(nil, Regexp.last_match[1]) }
    # Ticket
    str.gsub!(/ticket:(\d+)/, '#\1')
    # set the body as a comment
    #str.gsub!("\n", "\n> ")
    # str = "> #{str}"
    return str
  end
end

class Trac
  attr_reader :tickets, :changes, :sessions, :attachments, :milestones, :revisions

  def initialize(db)
    $logger.info('loading tickets')
    @db = db
    @tickets = @db[:ticket]
    @changes = @db[:ticket_change]
    @sessions = @db[:session_attribute]
    @attachments = @db[:attachment]
    @milestones = @db[:milestone]
    @revisions = @db[:revision]
  end
end

class Options < Hash
  def initialize(argv)
    super()
    opts = OptionParser.new do |opts|
      opts.banner = "#{$0}, available options:"
      opts.on('-c config', '--config', 'set the configuration file') do |c|
        self[:config] = c
      end
      opts.on_tail('-h', '--help', 'display this help and exit') do |help|
        puts(opts)
        exit
      end
      opts.on('-s', '--start-at ID', 'start migration from ticket with number <ID>') do |id|
        self[:start] = id
      end
      opts.on('-r', '--rev-map-file FILE',
              'allows to specify a commit revision mapping FILE') do |file|
        self[:revmapfile] = file
      end
      opts.on('-a', '--attachment-url URL',
              'if attachment files are reachable via a URL we reference this here') do |url|
        self[:attachurl] = url
      end
      opts.on('-S', '--single-post',
              'Put all issue comments in the first message.') do |single|
        self[:singlepost] = single
      end
      opts.on('-F', '--fast-import',
              'Import without safety-checking issue numbers.') do |fast|
        self[:fast] = fast
      end
      opts.on('-o', '--opened-only', 'Skips the import of closed tickets') do |o|
        self[:openedonly] = o
      end
      opts.on('-v', '--verbose', 'verbose mode') do |v|
        self[:verbose] = v
      end
      begin
        opts.parse!(argv)
        if not self[:config]
          default = File.join(File.dirname(__FILE__), 'config.yaml')
          raise 'missing configuration file' unless File.exists?(default)
          self[:config] = default
        end
        self[:start] = -1 unless self[:start]
      rescue => e
        STDERR.puts(e)
        STDERR.puts('run with -h to see available options')
        exit 1
      end
    end
  end
end

if __FILE__ == $0
  opts = Options.new(ARGV)
  cfg = YAML.load_file(opts[:config])

  # Setup logger.
  $logger = Logger.new(STDERR)
  $logger.level = opts[:verbose] ? Logger::DEBUG : Logger::INFO
  $logger.formatter = proc do |severity, datetime, progname, msg|
    time = datetime.strftime('%Y-%m-%d %H:%M:%S')
    "[#{time}] #{severity}#{' ' * (5 - severity.size + 1)}| #{msg}\n"
  end

  # Setup database.
  db = nil
  if db_url = cfg['trac']['database']
    db = Sequel.connect(db_url)
  end
  if not db
    $logger.error('could not connect to trac databse')
    exit 1
  end

  # load revision mapping file and convert it to a hash.
  # This revmap file allows to map between SVN revisions (rXXXX)
  # and git commit sha1 hashes.
  revmap = nil
  if opts[:revmapfile]
    File.open(opts[:revmapfile], "r") do |f|
      $logger.info(opts[:revmapfile])
      revmap = Hash[f.each_line
                     .map { |line| line.split(/\s+/) }
                     .map { |rev, sha| [rev.gsub(/^r/, ''), sha] } # remove leading "r" if present
      ]
    end
  end

  trac = Trac.new(db)

  migrator = Migrator.new(
    trac, cfg['github'], cfg['users'], cfg['labels'], revmap,
    opts[:attachurl], opts[:singlepost], (not opts[:fast]))
  #migrator.migrateVersions
  migrator.migrate(opts[:start], opts[:openedonly])
end
